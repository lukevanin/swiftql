{"metadata":{"title":"Select Queries","role":"article","modules":[{"name":"SwiftQL"}],"roleHeading":"Article"},"sections":[],"schemaVersion":{"patch":0,"major":0,"minor":3},"primaryContentSections":[{"content":[{"level":2,"type":"heading","anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"isActive":true,"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/GettingStarted","type":"reference"},{"text":" showed the fundamental principles behind SwiftQL. This","type":"text"},{"text":" ","type":"text"},{"text":"guide covers:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Joining tables","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Performing aggregate queries using group by and having clauses","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Sorting using order by","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Using limit and offset","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Subqueries","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Common table expressions","type":"text"}]}]}]},{"text":"Where","type":"heading","level":2,"anchor":"Where"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"reference","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/GettingStarted","isActive":true},{"type":"text","text":" showed "},{"type":"codeVoice","code":"Where"},{"type":"text","text":" clauses being used in select statements."},{"type":"text","text":" "},{"type":"text","text":"This section covers the capabilities of "},{"type":"codeVoice","code":"Where"},{"type":"text","text":" clauses in more detail."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The result of a "},{"type":"codeVoice","code":"Where"},{"type":"text","text":" expression always resolves to a boolean value. Rows for"},{"type":"text","text":" "},{"type":"text","text":"which the boolean value resolves to "},{"type":"codeVoice","code":"true"},{"type":"text","text":" are included in the result, and all"},{"type":"text","text":" "},{"type":"text","text":"other rows are excluded."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have already seen a simple "},{"type":"codeVoice","code":"Where"},{"type":"text","text":" expression where we check if a field is"},{"type":"text","text":" "},{"type":"text","text":"equal to a static value or a parameter:"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.id == \"fred\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A where expression can include multiple terms. SwiftQL does not impose any limit"},{"type":"text","text":" "},{"type":"text","text":"on the complexity of the "},{"type":"codeVoice","code":"Where"},{"type":"text","text":" clause:"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.id == \"fred\" || ((person.age > 21) && (person.age < 65))","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Refer to the "},{"type":"reference","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Expressions","isActive":true},{"type":"text","text":" guide for more details about expressions."}]},{"text":"Join","type":"heading","level":2,"anchor":"Join"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ability to join tables in a query is where relational databases really start"},{"type":"text","text":" "},{"type":"text","text":"to shine. SwiftQL supports cross join, inner join, and outer join."}]},{"style":"note","name":"Note","type":"aside","content":[{"inlineContent":[{"text":"SwiftQL does not currently support right joins.","type":"text"}],"type":"paragraph"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First let’s define an "},{"type":"codeVoice","code":"Occupation"},{"type":"text","text":" table that we can join to our "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" table:"}]},{"syntax":"swift","type":"codeListing","code":["import SwiftQL","","@SQLTable struct Occupation {","    var id: String","    var name: String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s create the table and insert some entries:"}]},{"syntax":"swift","type":"codeListing","code":["try database.makeRequest(with: sqlCreate(Occupation.self)).execute()","","let engineer = Occupation(id: \"eng\", name: \"Engineer\")","try database.makeRequest(with: sqlInsert(engineer)).execute()","","let scientist = Occupation(id: \"sci\", name: \"Scientist\")","try database.makeRequest(with: sqlInsert(scientist)).execute()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s also create some "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" entries linked to these occupations:"}]},{"syntax":"swift","type":"codeListing","code":["let joeBloggs = Person(id: \"joe-bloggs\", occupationId: \"eng\", name: \"Joe Bloggs\", age: \"25\")","try database.makeRequest(with: sqlInsert(joeBloggs)).execute()","","let janeDoe = Person(id: \"jane-doe\", occupationId: \"sci\", name: \"Jane Doe\", age: 45)","try database.makeRequest(with: sqlInsert(janeDoe)).execute()","","let davidSmith = Person(id: \"david-smith\", occupationId: \"sci\", name: \"David Smith\", age: 33)","try database.makeRequest(with: sqlInsert(davidSmith)).execute()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When joining multiple tables the result is often, although not always, a"},{"type":"text","text":" "},{"type":"text","text":"combination of columns from some or or all of the tables. To define an result"},{"type":"text","text":" "},{"type":"text","text":"with an arbitrary combination of columns we use a struct annotated with"},{"type":"text","text":" "},{"type":"codeVoice","code":"@SQLResult"},{"type":"text","text":"."}]},{"syntax":"swift","type":"codeListing","code":["import SwiftQL","","@SQLResult PersonOccupation {","    let personId: String","    let personName: String","    let occupationId: String?","    let occupationName: String?","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can now write a query that selects all of the people in the database with"},{"type":"text","text":" "},{"type":"text","text":"their occupation. The "},{"type":"codeVoice","code":"occupationId"},{"type":"text","text":" on the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" table is optional so when"},{"type":"text","text":" "},{"type":"text","text":"we join the "},{"type":"codeVoice","code":"Occupation"},{"type":"text","text":" table it is possible that the "},{"type":"codeVoice","code":"Occupation"},{"type":"text","text":" table will"},{"type":"text","text":" "},{"type":"text","text":"be "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":" for that person. To handle this we need to tell SwiftQL that we expect"},{"type":"text","text":" "},{"type":"text","text":"a "},{"inlineContent":[{"text":"nullable","type":"text"}],"type":"emphasis"},{"type":"text","text":" table to be returned."}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    let occupation = schema.nullableTable(Occupation.self)","    Select(","        PersonOccupation.columns(","            personId: person.id,","            occupationId: occupation.id,","            personName: person.name,","            occupationName: occupation.name","        )","    )","    From(person)","    Join.Left(occupation, on: occupation.id == person.occupationId)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We used the "},{"type":"codeVoice","code":"PersonOccupation.columns"},{"type":"text","text":" to instantiate a column set which"},{"type":"text","text":" "},{"type":"text","text":"uses fields from both the "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Occupation"},{"type":"text","text":" tables."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can also reference the fields of the result column set in the query:"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    let occupation = schema.nullableTable(Occupation.self)","    let row = PersonOccupation.columns(","        personId: person.id,","        occupationId: occupation.id,","        personName: person.name,","        occupationName: occupation.name","    )","    Select(row)","    From(person)","    Join.Left(occupation, on: occupation.id == person.occupationId)","    Where(row.personName != \"Fred\")","}"]},{"name":"Tip","type":"aside","style":"tip","content":[{"inlineContent":[{"text":"SwiftQL does not impose a limit on the  number of tables that can be","type":"text"},{"text":" ","type":"text"},{"text":"joined in a query.","type":"text"}],"type":"paragraph"}]},{"style":"tip","name":"Tip","type":"aside","content":[{"inlineContent":[{"text":"Use ","type":"text"},{"type":"codeVoice","code":"Join.Cross"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Join.Inner"},{"text":" to perform a cross or inner","type":"text"},{"text":" ","type":"text"},{"text":"join respectively.","type":"text"}],"type":"paragraph"}]},{"text":"Group By","type":"heading","level":2,"anchor":"Group-By"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the group by clause to return aggregate results, or results where a single"},{"type":"text","text":" "},{"type":"text","text":"row has a computation from multiple records, such as the total number of records"},{"type":"text","text":" "},{"type":"text","text":"matching some criteria."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s define a "},{"type":"codeVoice","code":"@SQLResult"},{"type":"text","text":" to return the total number of people for each"},{"type":"text","text":" "},{"type":"text","text":"occupation:"}]},{"syntax":"swift","type":"codeListing","code":["import SwiftQL","","@SQLResult struct OccupationAggregate {","    var occupationId: String","    var numberOfPeople: Int","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can write a query to select the person records grouped by their"},{"type":"text","text":" "},{"type":"codeVoice","code":"occupationId"},{"type":"text","text":", and use the "},{"type":"codeVoice","code":"count()"},{"type":"text","text":" aggregate function to compute the number"},{"type":"text","text":" "},{"type":"text","text":"of people for each occupation."}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    let row = result {","        OccupationAggregate(","            occupationId: person.occupationId,","            numberOfPeople: person.id.count()","        )","    }","    Select(row)","    From(person)","    GroupBy(person.occupationId)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftQL currently supports the following aggregate functions:"}]},{"rows":[[[{"inlineContent":[{"text":"Function","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Column type","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Usage","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"count()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Any","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Number of items in the result set.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"min()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Any comparable","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Minimum value in the result set.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"max()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Any comparable","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Maximum value in the result set.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"average()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Double","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Average (arithmetic mean) of values in the result set.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"sum()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Int or Double","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Additive sum of values in the result set.","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"code":"groupConcat()","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"text":"String","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Concatenation of all values in the result set.","type":"text"}],"type":"paragraph"}]]],"type":"table","header":"row"},{"type":"paragraph","inlineContent":[{"type":"text","text":"All of the aggregate functions accept a "},{"type":"codeVoice","code":"distinct"},{"type":"text","text":" boolean parameter. When set"},{"type":"text","text":" "},{"type":"text","text":"to "},{"type":"codeVoice","code":"true"},{"type":"text","text":", duplicate values will be discarded and only unique values will be"},{"type":"text","text":" "},{"type":"text","text":"included in the result set."}]},{"style":"important","name":"Important","type":"aside","content":[{"inlineContent":[{"text":"A group by clause must include at least one aggregate term. SwiftQL","type":"text"},{"text":" ","type":"text"},{"text":"currently does not enforce correctness of a query containing a group by clause.","type":"text"}],"type":"paragraph"}]},{"text":"Having","type":"heading","level":2,"anchor":"Having"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The having clause is used in conjunction with the group by clause to filter"},{"type":"text","text":" "},{"type":"text","text":"groups. Think of like a where clause but operating on groups instead of"},{"type":"text","text":" "},{"text":"individual rows. As an example we can filter our previous query to only include","type":"text"},{"text":" ","type":"text"},{"text":"occupations where there are two or more people with that occupation:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    let row = result {","        OccupationAggregate(","            occupationId: person.occupationId,","            numberOfPeople: person.id.count()","        )","    }","    Select(row)","    From(person)","    GroupBy(person.occupationId)","    Having(row.numberOfPeople >= 2)","}"]},{"text":"Order By","type":"heading","level":2,"anchor":"Order-By"},{"type":"paragraph","inlineContent":[{"text":"Query results can be sorted using the order by clause. Use the ","type":"text"},{"type":"codeVoice","code":"ascending"},{"text":" or","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"descending"},{"text":" functions on the column or columns to sort by:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    OrderBy(person.name.ascending())","}"]},{"type":"paragraph","inlineContent":[{"text":"To sort by multiple columns, include the columns in the order by clause:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    OrderBy(person.name.ascending(), person.age.descending())","}"]},{"text":"Limit and offset","type":"heading","level":2,"anchor":"Limit-and-offset"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Use the limit clause to specify the maximum number of items to return from a"},{"type":"text","text":" "},{"type":"text","text":"query. We can write a query to return the five youngest people in the database:"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    OrderBy(person.age.ascending())","    Limit(5)"]},{"type":"paragraph","inlineContent":[{"text":"The offset clause is used in conjunction with the limit clause. Offset skips a","type":"text"},{"text":" ","type":"text"},{"text":"number of rows, and is often used to paginate results from a large result set:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    OrderBy(person.age.ascending())","    Limit(5)","    Offset(10)"]},{"text":"Subqueries","type":"heading","level":2,"anchor":"Subqueries"},{"inlineContent":[{"text":"Subqueries can be used anywhere that a column is used, such as in a result for","type":"text"},{"text":" ","type":"text"},{"text":"a ","type":"text"},{"type":"codeVoice","code":"Select"},{"text":" query:","type":"text"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["@SQLResult struct OccupationCount {","    let occupation: String","    let numberOfPeople: Int","}"]},{"type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    let occupation = schema.table(Occupation.self)","    Select(","        OccupationCount.columns(","            occupation: occupation.name,","            numberOfPeople: subqueryExpression { _ in","                Select(count(person.id))","                From(person)","                Where(person.occupationId == occupation.id)","            }","        )","    )","    From(occupation)","}"],"syntax":null},{"inlineContent":[{"text":"Subqueries can also be used in place of a table in a ","type":"text"},{"code":"From","type":"codeVoice"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"Joine"},{"text":" clause:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(","        subqueryExpression { _ in","            Select(person)","            From(person)","            Where(person.age > 18)","        }","    )","    Where(person.age < 65)","}"],"syntax":"swift"},{"inlineContent":[{"text":"See the ","type":"text"},{"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Expressions#In-operator","isActive":true,"type":"reference"},{"text":" documentation for an example of using a","type":"text"},{"text":" ","type":"text"},{"text":"subquery with the ","type":"text"},{"type":"codeVoice","code":"in"},{"text":" operator.","type":"text"}],"type":"paragraph"},{"type":"heading","level":2,"text":"Union, Union All, Except, Intersect","anchor":"Union-Union-All-Except-Intersect"},{"inlineContent":[{"type":"text","text":"The result of two or more select statements can be combined into a compund query"},{"type":"text","text":" "},{"type":"text","text":"using the union, union all, except, or intersect operators."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Suppose we have a table representing a family tree, and we want to select the","type":"text"},{"type":"text","text":" "},{"text":"mother and father of each member in the tree.","type":"text"}]},{"inlineContent":[{"text":"We first define a table representing the family tree:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["@SQLTable struct Family {","    var name: String?","    var mom: String?","    var dad: String?","    var born: Date?","    var died: Date?","}"]},{"inlineContent":[{"text":"We also define a result set for the name of the family member and their parent:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["@SQLResult struct FamilyMemberParent {","    let name: String?","    let parent: String?","}"],"syntax":"swift"},{"inlineContent":[{"text":"We can select the mother and father for each family member, then combine the","type":"text"},{"text":" ","type":"text"},{"text":"results using a ","type":"text"},{"code":"union","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let query = sql { schema in","    \/\/ Define the tables used in the two queries.","    let familyMom = schema.table(Family.self)","    let familyDad = schema.table(Family.self)","","    \/\/ Define the result that reads the person's name and their mother's name.","    let momRow = FamilyMemberParent.columns(name: familyMom.name, parent: familyMom.mom)","","    \/\/ Define the result that reads the person's name and their fathers's name.","    let dadRow = FamilyMemberParent.columns(name: familyDad.name, parent: familyDad.dad)","","    \/\/ Fetch the name of the mother for each person.","    Select(momRow)","    From(familyMom)","","    \/\/ Use union to append the results of the second query.","    Union()","","    \/\/ Fetch the name of the father for each person.","    Select(dadRow)","    From(familyDad)","}"],"syntax":"swift"},{"inlineContent":[{"text":"Using a ","type":"text"},{"code":"UnionAll","type":"codeVoice"},{"text":", the final result contains the combined results of the first","type":"text"},{"text":" ","type":"text"},{"text":"query followed by the results of the second query. A ","type":"text"},{"code":"Union","type":"codeVoice"},{"text":" is similar except","type":"text"},{"text":" ","type":"text"},{"text":"duplicate rows are excluded.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Except"},{"text":" operator returns the results from the first query that are not also","type":"text"},{"text":" ","type":"text"},{"text":"in the second query, which is to say that the row is omitted if it is returned","type":"text"},{"text":" ","type":"text"},{"text":"by both queries.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"Intersect"},{"text":" operator returns rows that are present in both queries.","type":"text"}],"type":"paragraph"},{"type":"aside","style":"tip","content":[{"type":"paragraph","inlineContent":[{"text":"All of the select statements used in an compound query must return the","type":"text"},{"text":" ","type":"text"},{"text":"same data type.","type":"text"}]}],"name":"Tip"},{"level":2,"type":"heading","text":"Common table expressions","anchor":"Common-table-expressions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Common table expressions are a powerful feature of SQLite which allow SQL to be"},{"text":" ","type":"text"},{"text":"queried in a procedural way. Using common table expressions, SQL statements can","type":"text"},{"text":" ","type":"text"},{"text":"be encapsulated into separate expressions which can be used as tables in other","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"select statements within the same query."}]},{"inlineContent":[{"text":"To use a common table expression:","type":"text"}],"type":"paragraph"},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"text":"Call the ","type":"text"},{"type":"codeVoice","code":"commonTableExpression"},{"text":" function to create the common table","type":"text"},{"text":" ","type":"text"},{"text":"expression, passing a closure that returns a select query.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Call the ","type":"text"},{"code":"table","type":"codeVoice"},{"text":" function to identify the common table expression as a table.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Call ","type":"text"},{"type":"codeVoice","code":"with"},{"type":"text","text":" before "},{"type":"codeVoice","code":"select"},{"text":", to include the common table expression in","type":"text"},{"type":"text","text":" "},{"text":"the query.","type":"text"}],"type":"paragraph"}]}]},{"syntax":"swift","code":["let _ = sql { schema in","    let personCommonTable = schema.commonTableExpression { schema in","        let person = schema.table(Person.self)","        Select(person)","        From(person)","        Where(person.occupationId.notNull())","    }","    let person = schema.table(personCommonTable)","    With(personCommonTable)","    Select(person)","    From(person))"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is equivalent to the following SQL:"}]},{"syntax":"sql","code":["WITH "," personCommonTable AS (","  SELECT","   person.*","  FROM","   Person AS person","  WHERE","   person.occupationId NOTNULL",")","SELECT"," person.*","FROM"," personCommonTable AS person"],"type":"codeListing"},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"A common table expression cannot be used direcly in a select, from, or join:","type":"text"}],"type":"paragraph"}]},{"syntax":null,"code":["let _ = select(personCommonTable) \/\/ Error, cannot select from common table expression "],"type":"codeListing"},{"type":"heading","anchor":"Recursive-common-table-expressions","text":"Recursive common table expressions","level":3},{"inlineContent":[{"text":"Recursive common table expressions are common table expressions where the query","type":"text"},{"text":" ","type":"text"},{"text":"refers to itself. They are commonly used with hierarchical data sets.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"A recursive expression is written as the union of two or more queries, where the"},{"text":" ","type":"text"},{"type":"text","text":"first query provides the base case, or starting condition, and the remaining"},{"type":"text","text":" "},{"type":"text","text":"queries produce subsequent results."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"To create a recursive common table expression use","type":"text"},{"type":"text","text":" "},{"code":"recursiveCommonTableExpression","type":"codeVoice"},{"type":"text","text":" to create."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For our example let’s define a table to represent a hierarchical orag chart for"},{"type":"text","text":" "},{"type":"text","text":"a company:"}]},{"syntax":"swift","code":["@SQLTable struct Org {","    var name: String?","    var boss: String?","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We will also define an "},{"type":"codeVoice","code":"@SQLResult"},{"type":"text","text":" that we use to refer to the result of the"},{"type":"text","text":" "},{"type":"text","text":"recursive common table expression. This essentially defines a ‘table’ with a"},{"type":"text","text":" "},{"type":"text","text":"single column."}],"type":"paragraph"},{"syntax":"swift","code":["@SQLResult struct ScalarString {","    var value: String","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We can now create an expression which returns all of the members of the"},{"type":"text","text":" "},{"type":"text","text":"organisation from a person named Alice, and everyone below her."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We call "},{"type":"codeVoice","code":"recursiveCommonTableExpression"},{"type":"text","text":" passing the return type which is"},{"type":"text","text":" "},{"type":"text","text":"returned by the expression. In this case we use our "},{"type":"codeVoice","code":"ScalarString"},{"type":"text","text":" result which"},{"type":"text","text":" "},{"type":"text","text":"we defined above."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"recursiveCommonTableExpression"},{"type":"text","text":" closure provides a schema which we have"},{"type":"text","text":" "},{"type":"text","text":"seen before, as well as a second parameter which we can use to refer to the"},{"type":"text","text":" "},{"type":"text","text":"common table expression recursively."}],"type":"paragraph"},{"syntax":"swift","code":["let query = sql { schema in","","    let cte = schema.recursiveCommonTableExpression(ScalarString.self) { schema, cte in","        let org = schema.table(Org.self)","        \/\/ Define the initial value for the starting condition.","        let initialResult = ScalarString.columns(value: \"Alice\".toNullable())","        Select(initialResult)","        \/\/ Union the initial value with successive values.","        Union()","        \/\/ Select members from the org whose boss matches the current member","        Select(ScalarString.columns(value: org.name))","        From(org)","        Join.Cross(cte)","        Where(org.boss == cte.scalarValue)","    }","    ","    \/\/ Select members from the org whose names are returned by the common table expression.","    let org = schema.table(Org.self)","    With(cte)","    Select(org.name)","    From(org)","    Where(org.name.in(cte))","}"],"type":"codeListing"},{"text":"Combining recusive common tables with non-recursive common tables","level":3,"type":"heading","anchor":"Combining-recusive-common-tables-with-non-recursive-common-tables"},{"inlineContent":[{"type":"text","text":"When recursive common tables are used with other non-recursive common"},{"type":"text","text":" "},{"type":"text","text":"tables, the recursive common table must appear after the other common tables in"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"With"},{"type":"text","text":" statement."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We can now write a query to fetch all living ancestors of ‘Alice’, using the"},{"type":"text","text":" "},{"type":"text","text":"family tree table from our earlier example:"}],"type":"paragraph"},{"syntax":"swift","code":["let selectStatement = sql { schema in","    ","    let parentOfCommonTable = schema.commonTableExpression { schema in","        let family = schema.table(Family.self)","        let momRow = FamilyMemberParent.columns(name: family.name, parent: family.mom)","        let dadRow = FamilyMemberParent.columns(name: family.name, parent: family.dad)","        Select(momRow)","        From(family)","        Union()","        Select(dadRow)","        From(family)","    }","    ","    let ancestorOfAliceCommonTable = schema.recursiveCommonTableExpression(ScalarString.self) { schema, this in","        let parentOf = schema.table(parentOfCommonTable)","        Select(ScalarString.columns(value: parentOf.parent))","        From(parentOf)","        Where(parentOf.name == \"Alice\".toNullable())","        UnionAll()","        Select(ScalarString.columns(value: parentOf.parent))","        From(parentOf)","        Join.Inner(this, on: this.value == parentOf.name)","    }","    ","    let ancestorOfAlice = schema.table(ancestorOfAliceCommonTable)","    let family = schema.table(Family.self)","    ","    \/\/ Note the order of the common tables. The recursive common table must appear after other common tables.","    With(parentOfCommonTable, ancestorOfAliceCommonTable)","    Select(family.name)","    From(ancestorOfAlice)","    Join.Cross(family)","    Where((ancestorOfAlice.value == family.name) && family.died.isNull())","    OrderBy(family.born.ascending())","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Observe the order of definitions. We define an ordinary common table which"},{"type":"text","text":" "},{"type":"text","text":"selects the mother and  father for each family member. We then use this common"},{"type":"text","text":" "},{"type":"text","text":"table in the recursive common table expression. In the with clause the the"},{"type":"text","text":" "},{"type":"text","text":"recursive common table expression is placed last."}],"type":"paragraph"},{"name":"Warning","style":"warning","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"SwiftQL does not currently enforce the order of common table","type":"text"},{"text":" ","type":"text"},{"text":"expressions in the with clause. It is the programmer’s responsibility to ensure","type":"text"},{"text":" ","type":"text"},{"text":"that the recursive common table expression is always placed last in the with","type":"text"},{"text":" ","type":"text"},{"text":"clause.","type":"text"}]}]}],"kind":"content"}],"variants":[{"paths":["\/documentation\/swiftql\/queries"],"traits":[{"interfaceLanguage":"swift"}]}],"seeAlsoSections":[{"title":"Essentials","anchor":"Essentials","identifiers":["doc:\/\/SwiftQL\/documentation\/SwiftQL\/GettingStarted","doc:\/\/SwiftQL\/documentation\/SwiftQL\/LiveQueries","doc:\/\/SwiftQL\/documentation\/SwiftQL\/Expressions","doc:\/\/SwiftQL\/documentation\/SwiftQL\/BuiltinFunctions","doc:\/\/SwiftQL\/documentation\/SwiftQL\/FunctionalSyntax"],"generated":true}],"hierarchy":{"paths":[["doc:\/\/SwiftQL\/documentation\/SwiftQL"]]},"identifier":{"url":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Queries","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Use joins, aggregates, sorting, subqueries, and common table expressions."}],"kind":"article","references":{"doc://SwiftQL/documentation/SwiftQL/Expressions#In-operator":{"abstract":[],"title":"In operator","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Expressions#In-operator","type":"topic","kind":"section","url":"\/documentation\/swiftql\/expressions#In-operator"},"doc://SwiftQL/documentation/SwiftQL/GettingStarted":{"title":"Getting started","kind":"article","abstract":[{"text":"Introduces the basic concepts and usage of SwiftQL.","type":"text"}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/GettingStarted","type":"topic","url":"\/documentation\/swiftql\/gettingstarted","role":"article"},"doc://SwiftQL/documentation/SwiftQL/FunctionalSyntax":{"title":"Functional Syntax","kind":"article","abstract":[{"text":"Use functional syntax with SwiftQL.","type":"text"}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/FunctionalSyntax","type":"topic","url":"\/documentation\/swiftql\/functionalsyntax","role":"article"},"doc://SwiftQL/documentation/SwiftQL/BuiltinFunctions":{"url":"\/documentation\/swiftql\/builtinfunctions","role":"article","title":"Built-in Functions","type":"topic","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/BuiltinFunctions","abstract":[{"text":"Functions provided by SwiftQL.","type":"text"}],"kind":"article"},"doc://SwiftQL/documentation/SwiftQL/LiveQueries":{"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/LiveQueries","type":"topic","abstract":[{"text":"Use Combine Publishers to observe changes to the database.","type":"text"}],"url":"\/documentation\/swiftql\/livequeries","kind":"article","title":"Live queries","role":"article"},"doc://SwiftQL/documentation/SwiftQL/Expressions":{"title":"Expressions","kind":"article","abstract":[{"text":"In depth discussion of expressions in SwiftQL.","type":"text"}],"url":"\/documentation\/swiftql\/expressions","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Expressions","type":"topic","role":"article"},"doc://SwiftQL/documentation/SwiftQL":{"title":"SwiftQL","kind":"symbol","abstract":[{"type":"text","text":"Write SQL using familiar type-safe Swift syntax."}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL","type":"topic","url":"\/documentation\/swiftql","role":"collection"}}}