{"hierarchy":{"paths":[["doc:\/\/SwiftQL\/documentation\/SwiftQL"]]},"sections":[],"seeAlsoSections":[{"title":"Advanced topics","identifiers":["doc:\/\/SwiftQL\/documentation\/SwiftQL\/CustomFunctions","doc:\/\/SwiftQL\/documentation\/SwiftQL\/GenericTableParameters"],"generated":true,"anchor":"Advanced-topics"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftql\/customtypes"]}],"kind":"article","abstract":[{"text":"Create custom scalar types for table columns.","type":"text"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/CustomTypes"},"schemaVersion":{"patch":0,"minor":3,"major":0},"metadata":{"modules":[{"name":"SwiftQL"}],"role":"article","roleHeading":"Article","title":"Custom Types"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"text":"SwiftQL has the following built in data types: ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"code":"String","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"Data","type":"codeVoice"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"It is sometimes necessary to use a more specific type to accurately represent"},{"text":" ","type":"text"},{"type":"text","text":"data, or to simplify common query operations. SwiftQL allows you to create"},{"type":"text","text":" "},{"type":"text","text":"custom encoding for types that can be stored in the SQLite database."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Examples of where custom types might be used are for storing UUIDs, dates, or","type":"text"},{"text":" ","type":"text"},{"text":"other structured content.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This guide shows how to define custom types and use them in tables and queries.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"We cover two common use cases showing how to support Foundation "},{"code":"UUID","type":"codeVoice"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"code":"Date","type":"codeVoice"},{"text":" types.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"To allow a custom type to be used in SQL it needs to conform for the","type":"text"},{"type":"text","text":" "},{"code":"SQLCustomType","type":"codeVoice"},{"text":" protocol, and optionally one or more of the following:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"SQLEquatable","type":"codeVoice"},{"text":": Allow the type to be used in equality expressions (e.g. ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"!=","type":"codeVoice"},{"text":")","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"SQLComparable","type":"codeVoice"},{"type":"text","text":": Allow the type to be used in comparison expressions (e.g. "},{"code":">","type":"codeVoice"},{"type":"text","text":", "},{"code":"<","type":"codeVoice"},{"type":"text","text":", "},{"code":">=","type":"codeVoice"},{"type":"text","text":", "},{"code":"<=","type":"codeVoice"},{"type":"text","text":")"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Custom types are stored in the SQL database by as one of the native"},{"type":"text","text":" "},{"type":"text","text":"representations used by SQLite: "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", "},{"code":"Double","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"String"},{"type":"text","text":", or "},{"type":"codeVoice","code":"Data"},{"type":"text","text":". Custom"},{"type":"text","text":" "},{"type":"text","text":"types need to implement support to convert to and from one of these native"},{"type":"text","text":" "},{"type":"text","text":"representations when being written to and read from the database."}]},{"text":"UUID extension","level":2,"anchor":"UUID-extension","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Below is an example showing how we can add an extension to the Foundation "},{"type":"codeVoice","code":"UUID"},{"text":"","type":"text"},{"type":"text","text":" "},{"type":"text","text":"type to store the UUID as a string."}]},{"code":["\/\/ 1. Define the extension","extension UUID: XLCustomType, XLEquatable, XLComparable {","","    private enum InternalError: LocalizedError {","        case uuidInvalid(String)","","        var errorDescription: String? {","            switch self {","            case uuidInvalid(let rawValue):","                \"Data does not represent a valid UUID: \\(rawValue)\"","            }","        }","    }","    ","    \/\/ 2. Protocol conformance","    public typealias T = Self","    ","    \/\/ 3. Initialize the custom type from a database field.","    public init(reader: XLColumnReader, at index: Int) throws {","        let rawValue = reader.readText(at: index)","        guard let uuid =  UUID(uuidString: rawValue) else {","            throw InternalError.uuidInvalid(rawValue)","        }","        self = uuid","    }","    ","    \/\/ 4. Assign a value using out custom type in an SQL expression.","    public func bind(context: inout XLBindingContext) {","        context.bindText(value: uuidString)","    }","    ","    \/\/ 5. Encode our custom type into a database field.","    public func makeSQL(context: inout XLBuilder) {","        context.text(self.uuidString)","    }","    ","    \/\/ 6. Provide a default value.","    public static func sqlDefault() -> UUID {","        UUID(uuidString: \"00000000-0000-0000-0000-000000000000\")!","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Letâ€™s go through this step by step:"}]},{"items":[{"content":[{"inlineContent":[{"text":"We create an extension on ","type":"text"},{"type":"codeVoice","code":"UUID"},{"text":" which conforms to the ","type":"text"},{"type":"codeVoice","code":"XLCustomType"},{"text":"","type":"text"},{"text":" ","type":"text"},{"text":"protocol. We will implement the protocol conformance in the following steps.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"We also add conformance for ","type":"text"},{"type":"codeVoice","code":"XLEquatable"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"SQLComparable"},{"text":". We do not need","type":"text"},{"text":" ","type":"text"},{"text":"to implement anything for these two protocols since SwiftQL will provide","type":"text"},{"text":" ","type":"text"},{"text":"conformance automatically.","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"Add ","type":"text"},{"code":"public typealias T = Self","type":"codeVoice"},{"text":". This is necessary boilerplate to tell the","type":"text"},{"text":" ","type":"text"},{"text":"compiler that this extension implements the conformance for itself.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement the initializer. The initializer takes an ","type":"text"},{"code":"XLColumnReader","type":"codeVoice"},{"text":" and an","type":"text"},{"text":" ","type":"text"},{"text":"index. The ","type":"text"},{"code":"XLColumnReader","type":"codeVoice"},{"text":" lets us read the native data from the database. The","type":"text"},{"text":" ","type":"text"},{"code":"index","type":"codeVoice"},{"text":"represents the column which we need to read.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList","start":2},{"type":"paragraph","inlineContent":[{"text":"Our ","type":"text"},{"type":"codeVoice","code":"UUID"},{"text":" is encoded as a ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" which translates to an SQL ","type":"text"},{"type":"codeVoice","code":"Text"},{"text":" value. We","type":"text"},{"text":" ","type":"text"},{"text":"read the text value then instantiate our custom type.","type":"text"}]},{"items":[{"content":[{"inlineContent":[{"text":"Implement the ","type":"text"},{"code":"bind","type":"codeVoice"},{"text":" method. This method encodes our custom value when it","type":"text"},{"text":" ","type":"text"},{"text":"is used as a variable in an expression. Again, since our data is represented by","type":"text"},{"text":" ","type":"text"},{"text":"a ","type":"text"},{"code":"Text","type":"codeVoice"},{"text":" value, we can bind the string representation.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement the ","type":"text"},{"code":"makeSQL","type":"codeVoice"},{"text":" method. This method is used to encode our custom type","type":"text"},{"text":" ","type":"text"},{"text":"when it is used as a literal value in an expression.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement ","type":"text"},{"code":"sqlDefault","type":"codeVoice"},{"text":". This static method is used internally by SwiftQL when","type":"text"},{"text":" ","type":"text"},{"text":"preparing SQL queries. The only requirement is to provide a valid instance of","type":"text"},{"text":" ","type":"text"},{"text":"our custom type. The value itself does not matter.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList","start":4},{"type":"paragraph","inlineContent":[{"text":"This extension allows ","type":"text"},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" type to be used in SQL expressions, such as a a"},{"type":"text","text":" "},{"type":"text","text":"column in a table, or a conditions in a where clause:"}]},{"type":"codeListing","syntax":"swift","code":["@SQLTable struct Employee {","    let id: UUID","    let name: String","}","","let query = sql { schema in","    let employee = schema.table(Employee.self)","    Select(employee)","    From(employee)","    Where(employee.id == UUID(uuidString: \"536d0033-65a0-4142-8c21-99b6b891c4e8\"))","}"]},{"level":2,"type":"heading","text":"Date extension","anchor":"Date-extension"},{"type":"paragraph","inlineContent":[{"type":"text","text":"UUIDs were quite easy to support as there is a direct mapping between the type"},{"type":"text","text":" "},{"type":"text","text":"("},{"type":"codeVoice","code":"UUID"},{"type":"text","text":") and the representation ("},{"type":"codeVoice","code":"String"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example we show how to support a more complex use case, by adding"},{"type":"text","text":" "},{"type":"text","text":"support for Fundation "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Storing a "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" can introduce complications as there are many ways that dates"},{"type":"text","text":" "},{"type":"text","text":"can be represented depending on implementation requirements. For our purposes"},{"type":"text","text":" "},{"type":"text","text":"we will store the date using a standardized string representation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We will use the "},{"type":"codeVoice","code":"unixepoch"},{"type":"text","text":" to convert our text representation into a unix"},{"type":"text","text":" "},{"type":"text","text":"timestamp so that we can perform comparisons in a predictable way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Ideally the "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" would already be stored in a unix timestamp, however this"},{"type":"text","text":" "},{"type":"text","text":"example illustrates a common real world scenario where data often needs to be"},{"type":"text","text":" "},{"type":"text","text":"converted when it is used."}]},{"type":"codeListing","syntax":"swift","code":["extension Date: SQLCustomType, SQLEquatable, SQLComparable {","","    private enum InternalError: LocalizedError {","        case dataInvalid(String)","","        var errorDescription: String? {","            switch self {","            case dataInvalid(let rawValue):","                \"Data does not represent a valid Date: \\(rawValue)\"","            }","        }","    }","    ","    \/\/ 1. Define a formatter to use to encode and decode the date.","    static let dateFormatter: DateFormatter = {","        let formatter = DateFormatter()","        formatter.timezone = TimeZone.utc","        formatter.locale = .posix","        formatter.dateFormat = \"yyyy-MM-dd'T'HH:mm:ss.SSS\"","        return formatter","    }()","    ","    public typealias T = Self","    ","    public init(reader: XLColumnReader, at index: Int) {","        let rawValue = reader.readText(at: index)","        guard let date = self.dateFormatter.date(from: rawValue) else {","            throw InternalError.dateInvalid(rawValue)","        }","        self = date","    }","    ","    public func bind(context: inout XLBindingContext) {","        let rawValue = Self.dateFormatter.string(from: self)","        context.bindText(value: rawValue)","    }","","    \/\/ 2. Wrap Date values with the `unixepoch` function to convert it into a","    \/\/ number which can be used in computations and comparison operations.","    public static func wrapSQL(context: inout XLBuilder, builder: (inout XLBuilder) -> Void) {","        context.simpleFunction(name: \"unixepoch\") { context in","            context.listItem { context in","                builder(&context)","            }","        }","    }","","    \/\/ 3. Encode the Date when used in an SQL expression.","    public func makeSQL(context: inout XLBuilder) {","        Self.wrapSQL(context: &context) { context in","            context.text(Self.dateFormatter.string(from: self))","        }","    }","    ","    public static func sqlDefault() -> Date {","        Date(timeIntervalSince1970: 0)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The implementation of the "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" extension is similar to the "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" with some"},{"type":"text","text":" "},{"type":"text","text":"additional details. We discuss some of the differences below."}]},{"items":[{"content":[{"inlineContent":[{"text":"Add a static variable with a ","type":"text"},{"type":"codeVoice","code":"DateFormatter"},{"text":". This date formatter is used to","type":"text"},{"text":" ","type":"text"},{"text":"encode and decode the ","type":"text"},{"type":"codeVoice","code":"Date"},{"text":" to and from its string representation. The exact","type":"text"},{"text":" ","type":"text"},{"text":"format would depend on the application requirements.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement ","type":"text"},{"type":"codeVoice","code":"wrapSQL"},{"text":". This method is used by SwiftQL to all values read from","type":"text"},{"text":" ","type":"text"},{"text":"the database. We override the ","type":"text"},{"type":"codeVoice","code":"wrapSQL"},{"text":" method to inject a call to SQLiteâ€™s","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"unixepoch"},{"text":" function to transform our date from a string into a numerical","type":"text"},{"text":" ","type":"text"},{"text":"timestamp in order to perform computations, such as adding and subtracting","type":"text"},{"text":" ","type":"text"},{"text":"dates, and perform comparisons.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Implement ","type":"text"},{"type":"codeVoice","code":"makeSQL"},{"text":": This is similar to the ","type":"text"},{"type":"codeVoice","code":"UUID"},{"text":" example, except we need","type":"text"},{"text":" ","type":"text"},{"text":"to call ","type":"text"},{"type":"codeVoice","code":"wrapSQL"},{"text":" after converting our date.","type":"text"}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows how we might use our "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" in a table and query:"}]},{"type":"codeListing","syntax":"swift","code":["@SQLTable struct Invoice {","    let id: Int","    let dueDate: Date","}","","let dateParameter = SQLNamedBindingReference<Date>(name: \"date\")","","let query = sq; { schema in","    let invoice = schema.table(Invoice.self)","    Select(invoice)","    From(invoice)","    Where(invoice.dueDate < dateParameter)","}"]},{"level":2,"type":"heading","text":"Custom UUID","anchor":"Custom-UUID"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So far we have added SQL support to extisting types using extension. Custom"},{"type":"text","text":" "},{"type":"text","text":"types can also be defined as standalone objects. This example show how we can"},{"type":"text","text":" "},{"type":"text","text":"define a custom "},{"type":"codeVoice","code":"MyUUID"},{"type":"text","text":" standalone type which wraps a "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":":"}]},{"name":"Tip","style":"tip","type":"aside","content":[{"inlineContent":[{"text":"Use value types (","type":"text"},{"type":"codeVoice","code":"struct"},{"text":") for custom types.","type":"text"}],"type":"paragraph"}]},{"type":"codeListing","syntax":"swift","code":["struct MyUUID: SQLCustomType, Equatable {","    ","    public typealias T = Self","    ","    var wrappedValue: UUID","    ","    public init(_ wrappedValue: UUID) {","        self.wrappedValue = wrappedValue","    }","    ","    public init(reader: XLColumnReader, at index: Int) {","        wrappedValue = UUID(uuidString: reader.readText(at: index))!","    }","    ","    public func bind(context: inout XLBindingContext) {","        context.bindText(value: wrappedValue.uuidString)","    }","    ","    public func makeSQL(context: inout XLBuilder) {","        context.text(wrappedValue.uuidString)","    }","    ","    public static func wrapSQL(context: inout XLBuilder, builder: (inout XLBuilder) -> Void) {","        builder(&context)","    }","    ","    public static func sqlDefault() -> Wrapper {","        MyUUID(UUID(uuidString: \"00000000-0000-0000-0000-000000000000\")!)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The implementation for our custom UUID type is similar to the extension examples"},{"type":"text","text":" "},{"type":"text","text":"for "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" shown previously. The main difference is that we store a"},{"type":"text","text":" "},{"type":"codeVoice","code":"UUID"},{"type":"text","text":" instance in an instance variable."}]}]}],"references":{"doc://SwiftQL/documentation/SwiftQL/GenericTableParameters":{"title":"Generic Table Parameters","kind":"article","url":"\/documentation\/swiftql\/generictableparameters","identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/GenericTableParameters","type":"topic","abstract":[{"type":"text","text":"Use generic parameters on table definitions."}],"role":"article"},"doc://SwiftQL/documentation/SwiftQL":{"title":"SwiftQL","kind":"symbol","abstract":[{"type":"text","text":"Write SQL using familiar type-safe Swift syntax."}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL","type":"topic","url":"\/documentation\/swiftql","role":"collection"},"doc://SwiftQL/documentation/SwiftQL/CustomFunctions":{"title":"Custom Functions","kind":"article","abstract":[{"text":"Create custom functions that can be called from SQL expressions.","type":"text"}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/CustomFunctions","type":"topic","url":"\/documentation\/swiftql\/customfunctions","role":"article"}}}