{"identifier":{"url":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/BuiltinFunctions","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/SwiftQL\/documentation\/SwiftQL"],["doc:\/\/SwiftQL\/documentation\/SwiftQL","doc:\/\/SwiftQL\/documentation\/SwiftQL\/Documentation"]]},"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"abstract":[{"text":"Functions provided by SwiftQL.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"In this guide we will see some of the functions provided by SwiftQL, including"},{"type":"text","text":" "},{"type":"text","text":"functions provided natively by SQLite."}],"type":"paragraph"},{"anchor":"Conditional-functions","level":2,"type":"heading","text":"Conditional functions"},{"anchor":"iif","level":3,"type":"heading","text":"iif()"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"iif"},{"type":"text","text":" function in SwiftQL is a conditional function that returns one of two"},{"type":"text","text":" "},{"type":"text","text":"or more values based on a boolean expression. It functions similarly to a "},{"type":"codeVoice","code":"Case"},{"type":"text","text":""},{"type":"text","text":" "},{"type":"text","text":"statement, is logically equivalent to Swift’s’ "},{"type":"codeVoice","code":"if-then-else"},{"type":"text","text":", and returns a"},{"type":"text","text":" "},{"type":"text","text":"value based on the first true condition or a default value if all conditions are"},{"type":"text","text":" "},{"type":"text","text":"false."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The following SwiftQL code shows how to use the "},{"type":"codeVoice","code":"iif"},{"type":"text","text":" function:"}],"type":"paragraph"},{"code":["let statement = sql { schema in","    let person = schema.table(Person.self)","    let occupation = schema.nullableTable(Occupation.self)","    let result = PersonOccupation.columns(","        person: person.name,","        occupation: iif(","            occupation.name.isNull(), ","            then: \"Unemployed\", ","            else: \"Employed\"","        )","    )","    Select(result)","    From(person)","    Join.Left(occupation, on: occupation.id == person.occupationId)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"This statement returns the persons name in the "},{"type":"codeVoice","code":"person"},{"type":"text","text":" column, and the word"},{"type":"text","text":" "},{"type":"codeVoice","code":"Unemployed"},{"type":"text","text":" in the "},{"type":"codeVoice","code":"occupation"},{"type":"text","text":" column if the person’s occupation is "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"Employed"},{"type":"text","text":" if the person’s occupation is not "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"switchCase-when-and-else","level":3,"type":"heading","text":"switchCase(), when(), and else()"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"switchCase-when-then-else"},{"type":"text","text":" can be used to create conditional expressions"},{"type":"text","text":" "},{"type":"text","text":"matching more than one condition. SwiftSQL provides two variants."}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Condition matching:","type":"text"}]}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The first variant uses a constant term to match and behaves similar to a"},{"type":"text","text":" "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement in Swift, where multiple patterns are compared against a"},{"type":"text","text":" "},{"type":"text","text":"single condition."}],"type":"paragraph"},{"code":["let statement = sql { schema in","    let occupation = schema.table(Occupation.self)","    let result = OccupationColor.columns(","        occupation: occupation.name,","        color: switchCase(occupation.name)","            .when(\"Engineer\", then: \"Red\")","            .when(\"Scientist\", then: \"Blue\")","    )","    Select(result)","    From(occupation)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Boolean matching:","type":"text"}]}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The second variant behaves like an "},{"type":"codeVoice","code":"if"},{"type":"text","text":" statement with multiple boolean"},{"type":"text","text":" "},{"type":"text","text":"conditions, and uses the result from the first boolean condition that evaluates"},{"type":"text","text":" "},{"type":"text","text":"to "},{"type":"codeVoice","code":"true"},{"type":"text","text":"."}],"type":"paragraph"},{"code":["let statement = sql { schema in","    let occupation = schema.table(Occupation.self)","    let result = OccupationColor.columns(","        occupation: occupation.name,","        color: when(occupation.name == \"Artist\", then: \"Cyan\")","    )","    Select(result)","    From(occupation)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Else:","type":"text"}]}],"type":"paragraph"},{"inlineContent":[{"text":"Both variants produce an optional type by default, and return a ","type":"text"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" result if"},{"text":" ","type":"text"},{"type":"text","text":"none of the conditions match. We can use an "},{"type":"codeVoice","code":"else"},{"type":"text","text":" to specify a default"},{"type":"text","text":" "},{"type":"text","text":"expression which is used instead, which also changes the result to a"},{"type":"text","text":" "},{"type":"text","text":"non-optional type."}],"type":"paragraph"},{"type":"codeListing","code":["let statement = sql { schema in","    let occupation = schema.table(Occupation.self)","    let result = OccupationColor.columns(","        occupation: occupation.name,","        color: switchCase(occupation.name)","            .when(\"Engineer\", then: \"Red\")","            .when(\"Scientist\", then: \"Blue\")","            .else(\"Green\")","    )","    Select(result)","    From(occupation)","}","let sql = encoder.makeSQL(statement)","let rows = try database.makeRequest(with: statement).fetchAll()"],"syntax":"swift"},{"anchor":"Date-functions","level":2,"type":"heading","text":"Date functions"},{"anchor":"toUnixTimestamp","level":3,"type":"heading","text":"toUnixTimestamp()"},{"inlineContent":[{"type":"text","text":"Converts a string representation of a date to an integer representing the number"},{"type":"text","text":" "},{"type":"text","text":"of seconds since the unix epoch."}],"type":"paragraph"},{"type":"heading","level":2,"anchor":"Numeric-functions","text":"Numeric functions"},{"type":"heading","level":3,"anchor":"abs","text":"abs()"},{"type":"paragraph","inlineContent":[{"text":"Returns the absolute value of a numeric field.","type":"text"}]},{"text":"rounded()","anchor":"rounded","type":"heading","level":3},{"inlineContent":[{"type":"text","text":"Returns the numeric value rounded to the next integer."}],"type":"paragraph"},{"level":3,"text":"rounded(to:)","anchor":"roundedto","type":"heading"},{"inlineContent":[{"type":"text","text":"Returns the numeric value rounded to the provide number of decimal places."}],"type":"paragraph"},{"text":"floor","anchor":"floor","type":"heading","level":3},{"inlineContent":[{"text":"Returns the numeric value rounded to the largest integer less than or equal","type":"text"},{"text":" ","type":"text"},{"text":"to it.","type":"text"}],"type":"paragraph"},{"text":"String functions","anchor":"String-functions","type":"heading","level":2},{"text":"collate()","anchor":"collate","type":"heading","level":3},{"inlineContent":[{"text":"Specifies the collating sequence, or collation, for comparing ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" values.","type":"text"},{"text":" ","type":"text"},{"text":"Collations determine the order and equality of strings during operations such as","type":"text"},{"text":" ","type":"text"},{"code":"OrderBy","type":"codeVoice"},{"text":", ","type":"text"},{"code":"groupBy","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Join","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"Where","type":"codeVoice"},{"text":" clauses.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"SwiftQL provides three default collating sequences:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"binary"},{"type":"text","text":": Compares string data using "},{"type":"codeVoice","code":"memcmp()"},{"type":"text","text":", treating characters as raw"},{"type":"text","text":" "},{"type":"text","text":"byte sequences. This is the default collation."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"nocase"},{"type":"text","text":": Similar to "},{"type":"codeVoice","code":"binary"},{"type":"text","text":", but performs case-folding for ASCII characters"},{"type":"text","text":" "},{"type":"text","text":"(converting uppercase ASCII letters to their lowercase equivalents) before"},{"type":"text","text":" "},{"type":"text","text":"comparison. It does not handle full Unicode case-folding."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"rtrim"},{"type":"text","text":": Similar to "},{"type":"codeVoice","code":"binary"},{"type":"text","text":", but ignores trailing space characters during"},{"type":"text","text":" "},{"text":"comparison.","type":"text"}]}]}],"type":"unorderedList"},{"type":"heading","text":"printf()","anchor":"printf","level":3},{"type":"paragraph","inlineContent":[{"text":"Returns a formatted string. In SwiftQL ","type":"text"},{"code":"printf()","type":"codeVoice"},{"text":" is similar to the same","type":"text"},{"text":" ","type":"text"},{"text":"function provided by the standard C library.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Refer to the ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/sqlite.org\/printf.html"},{"text":" documentation for","type":"text"},{"text":" ","type":"text"},{"text":"more information.","type":"text"}]},{"anchor":"Type-conversion","level":2,"type":"heading","text":"Type conversion"},{"inlineContent":[{"type":"text","text":"SwiftQL adopts Swift’s conventions and requires expressions of different types"},{"text":" ","type":"text"},{"type":"text","text":"to be explicitly converted to a common type when used together in the"},{"text":" ","type":"text"},{"type":"text","text":"same expression."}],"type":"paragraph"},{"inlineContent":[{"text":"Type conversion of custom types should be implemented as required.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"toInt()","anchor":"toInt","level":3},{"type":"paragraph","inlineContent":[{"text":"Converts an expression of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":", ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" to an expression of","type":"text"},{"text":" ","type":"text"},{"text":"type ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"heading","text":"toDouble()","anchor":"toDouble","level":3},{"type":"paragraph","inlineContent":[{"text":"Converts an expression of type ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" or ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" to an expression of"},{"type":"text","text":" "},{"type":"text","text":"type "},{"code":"Double","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"heading","text":"toString()","anchor":"toString","level":3},{"inlineContent":[{"type":"text","text":"Converts an expression of type "},{"code":"Int","type":"codeVoice"},{"type":"text","text":", "},{"code":"Double","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"Data","type":"codeVoice"},{"text":" to an expression of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type "},{"code":"String","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"level":3,"text":"toData()","type":"heading","anchor":"toData"},{"inlineContent":[{"text":"Converts an expression of type ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" to an expression of type "},{"code":"Data","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftql\/builtinfunctions"]}],"metadata":{"modules":[{"name":"SwiftQL"}],"role":"article","roleHeading":"Article","title":"Built-in Functions"},"kind":"article","references":{"https://sqlite.org/printf.html":{"identifier":"https:\/\/sqlite.org\/printf.html","titleInlineContent":[{"type":"text","text":"SQLite printf"}],"type":"link","title":"SQLite printf","url":"https:\/\/sqlite.org\/printf.html"},"doc://SwiftQL/documentation/SwiftQL":{"title":"SwiftQL","role":"collection","type":"topic","kind":"symbol","abstract":[],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL","url":"\/documentation\/swiftql"},"doc://SwiftQL/documentation/SwiftQL/Documentation":{"title":"SwiftQL","role":"collectionGroup","kind":"article","type":"topic","abstract":[{"text":"Write SQL using familiar type-safe Swift syntax.","type":"text"}],"identifier":"doc:\/\/SwiftQL\/documentation\/SwiftQL\/Documentation","url":"\/documentation\/swiftql\/documentation"}}}