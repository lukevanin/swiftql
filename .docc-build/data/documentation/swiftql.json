{"metadata":{"role":"collection","title":"SwiftQL"},"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"text","text":"SwiftQL lets you write SQL using familiar type-safe Swift."}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","type":"heading","text":"Overview","level":2},{"inlineContent":[{"type":"text","text":"SwiftQL lets you write type-safe SQLite statements using familiar Swift syntax."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here is a quick example:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.name == 'Fred')","}"]},{"inlineContent":[{"type":"text","text":"This would be equivalent to writing the SQL:"}],"type":"paragraph"},{"type":"codeListing","syntax":"sql","code":["SELECT *","FROM Person AS person","WHERE person.name == 'Fred'"]},{"inlineContent":[{"type":"text","text":"SwiftQL is designed to look like SQLite SQL syntax, while keeping to the style"},{"type":"text","text":" "},{"type":"text","text":"and conventions of the Swift language."}],"type":"paragraph"},{"anchor":"When-to-use-SwiftQL","type":"heading","text":"When to use SwiftQL","level":2},{"inlineContent":[{"type":"text","text":"SwiftQL provides a safer way to write SQL to interact with an SQLite database,"},{"type":"text","text":" "},{"type":"text","text":"or if you need a portable self-hosted relational database. SwiftQL lets you:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create tables using "},{"code":"Create","type":"codeVoice"},{"type":"text","text":" statements,"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Modify the database using "},{"code":"Update","type":"codeVoice"},{"type":"text","text":", "},{"code":"Insert","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Delete","type":"codeVoice"},{"type":"text","text":" statements, and"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Query the database using "},{"code":"Select","type":"codeVoice"},{"type":"text","text":" statements."}]}]}]},{"anchor":"Why-SQLite","type":"heading","text":"Why SQLite?","level":2},{"inlineContent":[{"type":"text","text":"SQLite is a commonly used database used by many iOS and MacOS applications. It"},{"type":"text","text":" "},{"type":"text","text":"has been around forever, runs just about everywhere, and its charactaristics are"},{"type":"text","text":" "},{"type":"text","text":"generally well understood."}],"type":"paragraph"},{"anchor":"How-is-SwiftQL-different-to-SwiftData","type":"heading","text":"How is SwiftQL different to SwiftData?","level":2},{"inlineContent":[{"type":"text","text":"SwiftData is an object-relational mapping (ORM) framework that allows"},{"type":"text","text":" "},{"type":"text","text":"applications to persist an object graph. SwiftQL provides an interface to query"},{"type":"text","text":" "},{"type":"text","text":"and modify a relational database."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"With an ORM such as SwiftData the application primarly interacts with objects."},{"type":"text","text":" "},{"type":"text","text":"Relationships between objects are defined by member properties."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"With a relational database the application interacts with rows within tables."},{"type":"text","text":" "},{"type":"text","text":"Relationships are defined by joining tables using primary and foreign keys."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Call us biased but believe that relational databases are the Correct Way™️ to"},{"type":"text","text":" "},{"type":"text","text":"handle large and\/or complicated data sets efficiently."}],"type":"paragraph"},{"anchor":"Getting-started","type":"heading","text":"Getting started","level":2},{"inlineContent":[{"type":"text","text":"We briefly saw SwiftQL’s syntax in the overview. This section goes into more"},{"type":"text","text":" "},{"type":"text","text":"detail on composing and executing queries, including how to pass parameters."}],"type":"paragraph"},{"anchor":"Defining-tables","type":"heading","text":"Defining tables","level":3},{"inlineContent":[{"type":"text","text":"Before we can query our database we need to define the structure of our tables."},{"type":"text","text":" "},{"type":"text","text":"A table is defined using a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":", annotated with "},{"type":"codeVoice","code":"@SQLTable"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["import SwiftQL","","@SQLTable struct Person {","    var id: String","    var occupationId: String?","    var name: String","    var age: Int","} "]},{"inlineContent":[{"type":"text","text":"This defines a table named "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" with some properties. SwiftQL supports the"},{"type":"text","text":" "},{"type":"text","text":"following intrinsic (fundamental) properties which correspond to SQLite counter"},{"type":"text","text":" "},{"type":"text","text":"parts:"}],"type":"paragraph"},{"header":"row","type":"table","rows":[[[{"type":"paragraph","inlineContent":[{"type":"text","text":"SwiftQL"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"SQLite"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Bool"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"INTEGER (0 or 1)"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Int"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"INTEGER"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Double"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"REAL"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"String"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"TEXT"}]}]],[[{"type":"paragraph","inlineContent":[{"type":"text","text":"Data"}]}],[{"type":"paragraph","inlineContent":[{"type":"text","text":"BLOB"}]}]]]},{"inlineContent":[{"type":"text","text":"SwiftQL also supports optional types, which correspond to a "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":" column in"},{"type":"text","text":" "},{"type":"text","text":"SQLite."}],"type":"paragraph"},{"anchor":"Creating-tables","type":"heading","text":"Creating tables","level":3},{"inlineContent":[{"type":"text","text":"Before you can use your table you need to create it. In SwiftQL we can use the"},{"type":"text","text":" "},{"type":"codeVoice","code":"sqlCreate"},{"type":"text","text":" helper function to create a basic table. SwiftQL also allows you to"},{"type":"text","text":" "},{"type":"text","text":"to create tables using "},{"type":"codeVoice","code":"Select"},{"type":"text","text":" statements, which we will look at later."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let createPersonStatement = sqlCreate(Person.self)"]},{"inlineContent":[{"type":"text","text":"This would be equivalent to writing the following SQL:"}],"type":"paragraph"},{"type":"codeListing","syntax":"sql","code":["CREATE TABLE IF NOT EXISTS Person (","    id TEXT NOT NULL,","    occupationId TEXT NULL,","    name TEXT NOT NULL,","    age INT NOT NULL",");"]},{"inlineContent":[{"type":"text","text":"SwiftQL translates to the Swift types to a compatible intrinsic type in SQLite."},{"type":"text","text":" "},{"type":"text","text":"Non-optional fields are been defined as "},{"type":"codeVoice","code":"NOT NULL"},{"type":"text","text":", while optional fields are"},{"type":"text","text":" "},{"type":"text","text":"defined as "},{"type":"codeVoice","code":"NULL"},{"type":"text","text":"."}],"type":"paragraph"},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"IF NOT EXISTS"},{"type":"text","text":" term is added by SwiftQL, and informs SQLite to"},{"type":"text","text":" "},{"type":"text","text":"bypass creating the table if it already exists. This allows us to safely execute"},{"type":"text","text":" "},{"type":"text","text":"the  create statement when our app starts, without first needing to check if the"},{"type":"text","text":" "},{"type":"text","text":"table already exists."}]}]},{"anchor":"Executing-statements","type":"heading","text":"Executing statements","level":3},{"inlineContent":[{"type":"text","text":"SwiftQL provides a default implementation using GRDB for running statements"}],"type":"paragraph"},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Support for alternative database providers is currently under"},{"type":"text","text":" "},{"type":"text","text":"development."}]}]},{"inlineContent":[{"type":"text","text":"First we initialize our database:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let directory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]","let file = directory.appending(path: \"my_database.sqlite\")","let database = try GRDBDatabase(url: file)"]},{"inlineContent":[{"type":"text","text":"Once the database is initialised, we can create and execute the statement:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["try database.makeRequest(with: createPersonStatement).execute()"]},{"inlineContent":[{"type":"text","text":"The database initialization and table creation only needs to happen once in the"},{"type":"text","text":" "},{"type":"text","text":"application life cycle."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We will follow this pattern of creating and executing statements throughout this"},{"type":"text","text":" "},{"type":"text","text":"tutorial."}],"type":"paragraph"},{"anchor":"Inserting-data","type":"heading","text":"Inserting data","level":3},{"inlineContent":[{"type":"text","text":"Our database has been created but it is currently empty. Let’s add some data."},{"type":"text","text":" "},{"type":"text","text":"First we create an instance of our table struct:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["let fredPerson = Person(","    id: \"fred\",","    occupationId: nil,","    name: \"Fred\",","    age: \"31\"",")"]},{"inlineContent":[{"type":"text","text":"We can then create and execute the request:"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["try database.makeRequest(with: sqlInsert(fredPerson)).execute()"]},{"inlineContent":[{"type":"text","text":"This is equivalent to running the following SQL:"}],"type":"paragraph"},{"type":"codeListing","syntax":"sql","code":["INSERT INTO Person (id, occupationId, name, age)","VALUES ('fred', NULL, 'Fred', 31)"]},{"anchor":"Running-select-queries","type":"heading","text":"Running select queries","level":3},{"inlineContent":[{"type":"text","text":"Now that we have some data, we can run the select query we enountered"},{"type":"text","text":" "},{"type":"text","text":"previously. First we prepare the query, then execute it:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.name == 'Fred')","}","let result = try database.makeRequest(with: query).fetchAll()"]},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"result"},{"type":"text","text":" will contain an array of "},{"type":"codeVoice","code":"Person"},{"type":"text","text":" objects matching the query."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"We used "},{"type":"codeVoice","code":"fetchAll"},{"type":"text","text":" to execute a select query instead of calling  "},{"type":"codeVoice","code":"execute"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Using "},{"type":"codeVoice","code":"fetchAll"},{"type":"text","text":" returns an array of all of the matching records for the query."},{"type":"text","text":" "},{"type":"text","text":"We can also use "},{"type":"codeVoice","code":"fetchOne"},{"type":"text","text":" to fetch only the first result from the query."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let firstResult = try database.makeRequest(with: query).fetchOne()"]},{"anchor":"Prepared-statements","type":"heading","text":"Prepared statements","level":3},{"inlineContent":[{"type":"text","text":"So far we have made the request each time we needed to execute it. Instead we"},{"type":"text","text":" "},{"type":"text","text":"can store the request and reuse it later. When the request is created SwiftQL"},{"type":"text","text":" "},{"type":"text","text":"will use an SQLite prepared statement. SQLite will parse the SQL string into"},{"type":"text","text":" "},{"type":"text","text":"low-level byte code which can be executed efficiently, without needing to parse"},{"type":"text","text":" "},{"type":"text","text":"the SQL each time. Re-using requests can potentially improve performance of"},{"type":"text","text":" "},{"type":"text","text":"complex queries at runtime."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.age >= 21 && person.age < 65)","}","let request = try database.makeRequest(with: query)"]},{"inlineContent":[{"type":"text","text":"Once created we can call the prepared statement whenever it is needed."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let result = try request.fetchAll()"]},{"anchor":"Variables","type":"heading","text":"Variables","level":3},{"inlineContent":[{"type":"text","text":"SwiftQL allows you to use variables in queries in a type-safe manner."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"First define a variable binding using the generic "},{"type":"codeVoice","code":"XLNamedBindingReference"},{"type":"text","text":", and"},{"type":"text","text":" "},{"type":"text","text":"specifying the type of the variable, as well as a name. The name is used for"},{"type":"text","text":" "},{"type":"text","text":"debugging SQL statements as does not affect the query:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let nameParameter = XLNamedBindingReference<String>(name: \"name\")"]},{"inlineContent":[{"type":"text","text":"We can include the variable parameter in a query:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let query = sql { schema in","    let person = schema.table(Person.self)","    Select(person)","    From(person)","    Where(person.name == nameParameter)","}","let request = try database.makeRequest(with: query)"]},{"inlineContent":[{"type":"text","text":"This is equivalent to the following SQL:"}],"type":"paragraph"},{"type":"codeListing","syntax":"sql","code":["SELECT *","FROM Person AS person","WHERE person.name == :name"]},{"inlineContent":[{"type":"text","text":"The name parameter is not assigned to a value yet. We assign the parameter value"},{"type":"text","text":" "},{"type":"text","text":"when we execute the query. A best practice when assigning parameters is to"},{"type":"text","text":" "},{"type":"text","text":"create a copy of the request then assign the parameter. We can take advantage of"},{"type":"text","text":" "},{"type":"text","text":"copy-on-write semantics for value types:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["var newRequest = request","newRequest.set(nameParameter, \"Fred\")","return try request.fetchAll()"]},{"inlineContent":[{"type":"text","text":"This binds the value “Fred” to the name parameter in the context of the request"},{"type":"text","text":" "},{"type":"text","text":"before fetching all of the matching results."}],"type":"paragraph"}]}],"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Documentation\/documentation\/SwiftQL"},"hierarchy":{"paths":[[]]},"kind":"article"}